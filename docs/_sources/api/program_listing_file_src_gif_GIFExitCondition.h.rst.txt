
.. _program_listing_file_src_gif_GIFExitCondition.h:

Program Listing for File GIFExitCondition.h
===========================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_gif_GIFExitCondition.h>` (``src/gif/GIFExitCondition.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef GENIF_GIFEXITCONDITION_H
   #define GENIF_GIFEXITCONDITION_H
   
   #include "Tree.h"
   #include <src/kernels/Kernel.h>
   #include <src/kernels/MaternKernel.h>
   #include <src/kernels/RBFKernel.h>
   
   namespace genif {
       class GIFExitCondition {
       public:
           virtual bool shouldExitRecursion(const Tree& node) const = 0;
       };
   
       class GIFExitConditionAverageKernelValue : public GIFExitCondition {
       public:
           GIFExitConditionAverageKernelValue(const GIFExitConditionAverageKernelValue&) = delete;
           GIFExitConditionAverageKernelValue& operator=(const GIFExitConditionAverageKernelValue&) = delete;
   
           explicit GIFExitConditionAverageKernelValue(const std::string& kernelId, const VectorX& kernelScaling, data_t sigma) : _sigma(sigma) {
               if (kernelId == "rbf") {
                   _kernel = new RBFKernel(kernelScaling[0]);
               } else if (kernelId == "matern-d1") {
                   _kernel = new MaternKernel(kernelScaling, 1);
               } else if (kernelId == "matern-d3") {
                   _kernel = new MaternKernel(kernelScaling, 3);
               } else if (kernelId == "matern-d5") {
                   _kernel = new MaternKernel(kernelScaling, 5);
               } else {
                   throw std::runtime_error("GIFExitConditionAverageKernelValue::GIFExitConditionAverageKernelValue: Unknown kernel supplied ('" + kernelId
                                            + "'). "
                                              "Possible choices are: rbf, matern-d1, matern-d3, matern-d5.");
               }
           };
   
           bool shouldExitRecursion(const Tree& node) const override {
               auto* accuArray = new data_t[node.vectorIndices.size()];
               for (unsigned int i = 0; i < node.vectorIndices.size(); i++)
                   accuArray[i] = _kernel->operator()(node.dataset.row(node.representativeIndex), node.dataset.row(node.vectorIndices[i]));
   
               data_t accu = 0.0;
   #pragma omp simd reduction(+ : accu)
               for (unsigned int i = 0; i < node.vectorIndices.size(); i++)
                   accu += accuArray[i];
   
               delete[] accuArray;
               return accu / static_cast<data_t>(node.vectorIndices.size()) >= _sigma;
           }
   
           virtual ~GIFExitConditionAverageKernelValue() {
               delete _kernel;
           }
   
       private:
           Kernel* _kernel;
           data_t _sigma = 1.0;
       };
   }
   
   #endif // GENIF_GIFEXITCONDITION_H
