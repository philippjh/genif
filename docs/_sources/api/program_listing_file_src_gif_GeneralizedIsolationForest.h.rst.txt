
.. _program_listing_file_src_gif_GeneralizedIsolationForest.h:

Program Listing for File GeneralizedIsolationForest.h
=====================================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_gif_GeneralizedIsolationForest.h>` (``src/gif/GeneralizedIsolationForest.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef GENIF_GENERALIZEDISOLATIONFOREST_H
   #define GENIF_GENERALIZEDISOLATIONFOREST_H
   
   #include "GeneralizedIsolationTree.h"
   #include <src/BaggingEnsemble.h>
   #include <src/Learner.h>
   #include <src/OutlierDetectionResult.h>
   #include <src/Tools.h>
   #include <src/gif/GIFModel.h>
   
   namespace genif {
       class GeneralizedIsolationForest : public Learner<std::vector<GIFModel>, VectorX> {
       public:
           GeneralizedIsolationForest(unsigned int k, unsigned int nModels, unsigned int sampleSize, const std::string& kernelId, const VectorX& kernelScaling, data_t sigma,
                                      int workerCount = -1) :
               _exitCondition(kernelId, kernelScaling, sigma),
               _gTree(k, _exitCondition, genif::Tools::handleWorkerCount(workerCount)), _gtrBagging(_gTree, nModels, sampleSize, genif::Tools::handleWorkerCount(workerCount)) {
           }
   
           Learner<std::vector<GIFModel>, VectorX>& fit(const MatrixX& dataset) override {
               _gtrBagging.fit(dataset);
               return *this;
           }
   
           VectorX predict(const MatrixX& dataset) const override {
               // Get predictions.
               const std::vector<OutlierDetectionResult>& predictions = _gtrBagging.predict(dataset);
   
               // Average over predictions.
               VectorX y(dataset.rows());
               for (unsigned int i = 0; i < dataset.rows(); i++) {
                   data_t predictionSum = 0.0;
                   for (unsigned int j = 0; j < _gtrBagging.getActualNumberOfModels(); j++)
                       predictionSum += predictions[j].getProbabilities()[i];
                   y[i] = predictionSum / static_cast<data_t>(_gtrBagging.getActualNumberOfModels());
               }
               return y;
           }
   
           std::vector<GIFModel> getModel() const override {
               return _gtrBagging.getModel();
           }
   
           ~GeneralizedIsolationForest() override = default;
   
       private:
           GIFExitConditionAverageKernelValue _exitCondition;
           GeneralizedIsolationTree _gTree;
           BaggingEnsemble<GIFModel, OutlierDetectionResult> _gtrBagging;
       };
   }
   
   #endif // GENIF_GENERALIZEDISOLATIONFOREST_H
