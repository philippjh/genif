
.. _program_listing_file_src_BaggingEnsemble.h:

Program Listing for File BaggingEnsemble.h
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_BaggingEnsemble.h>` (``src/BaggingEnsemble.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef GENIF_BAGGINGENSEMBLE_H
   #define GENIF_BAGGINGENSEMBLE_H
   
   #include <chrono>
   #include <random>
   #include <src/Learner.h>
   
   namespace genif {
       template<typename ModelType, typename PredictionType>
       class BaggingEnsemble : public Learner<std::vector<ModelType>, std::vector<PredictionType>> {
       public:
           explicit BaggingEnsemble(const Learner<ModelType, PredictionType>& baseLearner, unsigned int nModels = 100, unsigned int sampleSize = 256, unsigned int workerCount = 1,
                                    int seed = -1) :
               _baseLearner(baseLearner), _seed(seed) {
               // Check property validity.
               if (nModels <= 0)
                   throw std::runtime_error("BaggingEnsemble::BaggingEnsemble: nModels needs to be greater than zero.");
               if (sampleSize <= 0)
                   throw std::runtime_error("BaggingEnsemble::BaggingEnsemble: sampleSize needs to be greater than zero.");
               if (workerCount <= 0)
                   throw std::runtime_error("BaggingEnsemble::BaggingEnsemble: workerCount needs to be greater than zero.");
   
               // Assign properties.
               _nModels = nModels;
               _sampleSize = sampleSize;
               _workerCount = workerCount;
           }
   
           Learner<std::vector<ModelType>, std::vector<PredictionType>>& fit(const MatrixX& dataset) override {
               // Create PRNG.
               std::default_random_engine generator(_seed >= 0 ? _seed : std::chrono::system_clock::now().time_since_epoch().count());
               std::uniform_int_distribution<int> distribution(0, dataset.rows() - 1);
   
               // Remove all existing models.
               _models.clear();
   
               // Estimate new models.
   #pragma omp parallel for ordered num_threads(_workerCount)
               for (unsigned int i = 0; i < _nModels; i++) {
                   // Take a copy of the base learner.
                   auto learnerCopy = _baseLearner.copy();
   
                   // Sample dataset with replacement.
                   MatrixX sampledDataset(_sampleSize, dataset.cols());
                   for (unsigned int j = 0; j < _sampleSize; j++)
   #pragma omp ordered
                       sampledDataset.row(j) = dataset.row(distribution(generator));
   
                   // Fit base learner with sampled dataset.
                   learnerCopy->fit(sampledDataset);
   
                   // Add estimated model to the models vector.
   #pragma omp critical
                   _models.push_back(std::move(learnerCopy->getModel()));
               }
   
               // Return self.
               return *this;
           }
   
           std::vector<PredictionType> predict(const MatrixX& dataset) const override {
               // Create vector of predictions.
               std::vector<PredictionType> predictions;
               predictions.reserve(_models.size());
   
               // Make predictions from models.
               for (auto& model : _models)
                   predictions.push_back(_baseLearner.predict(dataset, model));
   
               return predictions;
           }
   
           std::vector<ModelType> getModel() const {
               return _models;
           }
   
           unsigned int getNumberOfModels() const {
               return _nModels;
           }
   
           unsigned int getActualNumberOfModels() const {
               return _models.size();
           }
   
       private:
           const Learner<ModelType, PredictionType>& _baseLearner;
           unsigned int _nModels;
           unsigned int _sampleSize;
           unsigned int _workerCount;
           int _seed;
   
           std::vector<ModelType> _models;
       };
   }
   
   #endif // GENIF_BAGGINGENSEMBLE_H
